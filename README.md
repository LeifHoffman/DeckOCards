# DeckOCards
## Introduction
Hello! My name is Leif Hoffman and this is a program I'm working on for one of my classes. For now, I'm calling the program "Deck O Cards" since that's what the program simulates; cards! As of currently, my program has two games that use a standard deck of 52 playing cards, War and Scoundrel. War is a classic game that most people know, but Scoundrel is likely one you haven't heard of. I may plan on adding more games in the future, but hopefully you will enjoy the ones that are currently available!

## About Myself
My name is Leif Hoffman and I'm a computer engineer at Elizabethtown College in PA. Ever since taking a CS I course, I've been enamored by the coding world and have enjoyed making all sorts of programs, from using Python's tKinter to make GUIs to making the game you see here! I usually spend my free time swimming for the team at Etown or playing video games with my friends. Hopefully you enjoy the games I've added!

## About The Games

### War
After making the initial deck and card structures, I felt it was time to start adding games. War was the first game I decided to add, since it's a game that most people have familiarity with it and it's simplicity would be a good start for working with a programmed deck of cards. Going through a quick rundown of War, a standard deck of 52 face-down cards is split evenly between two players (in this case, the user and computer). Throughout the game, both players reveal the top card of their deck and compare the values. The player with the higher value card wins and takes both cards into a winning pile. If the players have the same value on their cards, they enter 'war', where both players draw two additional cards face down, followed by a third card which is revealed and compared again. The winner of war takes all drawn cards into their winning pile. If a player runs out of cards, they refill their hand with their shuffled winning pile. If they have no cards to refill with, the other player is declared the winner.

Splitting the deck and drawing cards for both players was fairly easy to implement, where I just initialized a deck of cards, ran it through a shuffle function, then split every other card between the players. Actually tracking cards between players was the tricky part, as I used two counters to go through each player's cards. These counters would be compared to how many cards each player had, resetting when the counters reached each individual's final card, additionally signalling to shuffle in a win pile. I handled won cards by putting all played cards into a 'hold' card array, which capped at 52 cards. Upon winning, all cards would be put into a player's win pile, where they would be saved for later. This also accountted for during war, where more cards would just be added to hold. Whenever a player would reach their final card in hand, I reset the counter and refilled their hand using their won cards. Since I'm utilizing dynamic allocation, I needed to track how many cards are actually available for a player, so no more or less cards would be counted when refilling a hand. This was done by using tracking integer variables that changed as cards were played. Logisticly, if the players revealed their top card and there was a winner, one player would be up one card and the other would be down one card, and that is reflected when played. The functionality of the war mechanic was also difficult to fully develop, since multiple cards would be drawn before comparing values. This would mean I had to check every time that players had cards to play, and if someone could not, a winner would be chosen. There is variation on how people play around this instance, but I found ending the game at not having enough cards made it simplier to handle over all.

I'm fairly happy with this first game and my implimentation of it. There are still a bug or two that I hope to fix in the future (elaborated later on) but I am satisfied with where it is at.

### Scoundrel
Following War, I was trying to think of single-player card games that I could reasonably add, given the span of time left for completing the project. During the project, I remembered a game I found about half a year ago on YouTube called Scoundrel. It isn't as widely known as War, but what inspired me to program it is the game's compact, yet complex nature. There are many videos covering Scoundrel, but the original source of the game by Zach Gage and Kurt Bieg can be found at the link below:

http://www.stfj.net/art/2011/Scoundrel.pdf

The rules are covered in greater detail in the pdf above, but I'll quickly cover how it works. Players enter a 'dungeon', which consists of 44 cards, including all cards found in a standard 52-card deck except the red face and ace cards. The first four cards are revealed, creating a 'room'. Starting at 20 health, players progress through each room by selecting one card at a time, winning when all cards are interacted with. Rooms refill after players choose three cards, with the remaining card carrying over to the next room and filling with the next three cards in the deck. Rooms can be skipped, where the current cards are placed at the bottom of the dungeon and the next four cards are revealed, but can only be done once every other room not skipped. Cards are split by suit, where spades and clubs are monsters, diamonds are weapons, and hearts are healing potions. Monsters reduce player health by their card value (10 = 10, Jack = 11, Queen = 12, King = 13, Ace = 14). Weapons automatically equip when interacted with, and reduce monster damage to a minimum of zero, but are then limited to slaying monsters to less value until a new weapon is equipped. Potions heal their card value up to a maximum of 20. In the original ruleset, only a single potion could be used per room, discarding any other found potions. However, after playing and testing the game myself, I found that the rule on limited healing was an additional struggle on an already difficult game, so I decided to include the option to disable this limitation. This change is currently the only difference I have made to the original game rules. If a player's health reached zero, they lose, and if a player reaches the final encounter, they win.

When I started to program this game, I was aware that there were going to be a lot more things to keep track of. Although there were fewer cards in the deck and I didn't need to shuffle, I still would need to implement card suits functioning in different ways and the skipping functionality. Starting out, I initialized a deck of 52 cards, then put all cards into another deck which excluded diamond and heart cards with a value greater than 10, making a dungeon of 44 cards. I then implemented several variables representing player stats, such as the player's health, their current weapon, the last monster slayed with the weapon, and the amount of encounters left in the dungeon. I used a while loop that ran until the dungeon size reached zero, which essentially was a counter that reduced each time an encounter was chosen. On the topic of encounters, I handled setting them up by taking the first four cards of the dungeon (selected by a counter), putting them into a dynamic card array called 'room', and then displaying each card as an option. When selected, the card would go through a function that would change the outcome based on the card's suit, and would take into consideration the card's value, the player's health, weapon, last fought monster, and if the original ruleset is active. The logic for how encounters would work as described above went into this function. After completing the encounter, I would set the encounter's value to zero, which signified it was 'cleared' and could not be selected again. The room and dungeon size would also decrease by one after the encounter. Once a room reached a size of one card, the room would replace old cards with new ones if a card's value was set to zero (cleared). This made it easy to check for what three cards would need to be replaced regardless of which three are chosen for a given room. The room refill also keeps in the mind the size of the dungeon, and stops filling a room if no more cards are available to pull from. Beyond going through the rooms normally, making the skip functionallity was the hardest part, which I go into greater detail in the "Problems Encountered" section. There is one aspect, however, that was a problem more based in gameplay rather than actual coding difficulty and that was testing the end of the game. As I mentioned earlier, the game is quite difficult, even with the healing limitation removed. For that reason, it was challenging to test how the game would function when at a late-game state (at 8 or less cards to go). To remedy this problem, I inserted a 'cheat' character which automatically cleared the first three encounters in a room and reduced dungeon size without affecting the player. This made testing things like endgame room refilling and skipping much easier to do, especially since skipping should push the current cards to the back of the dungeon. 

I think that Scoundrel was a really good addition to the selection of games, adding a lot more diversity in gameplay compared to War. I would like to add more card games of that variety in the future if I have time to.

## Problems Encountered
A lot (To be updated)

## Reflection
It was fun :P (Please update this!)